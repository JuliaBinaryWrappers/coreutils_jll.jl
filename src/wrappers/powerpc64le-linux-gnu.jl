# Autogenerated wrapper script for coreutils_jll for powerpc64le-linux-gnu
export b2sum, base32, base64, basename_bin, basenc, cat_bin, chcon, chgrp, chmod_bin, chown_bin, chroot, cksum, comm, cp_bin, csplit, cut, date, dd, df, dir, dircolors, dirname_bin, du, echo, env, expand, expr, factor, false_bin, fmt, fold, groups, head, hostid, id, install, join_bin, kill_bin, left_bracket, libstdbuf, link, ln, logname, ls, md5sum, mkdir_bin, mkfifo, mknod, mktemp_bin, mv_bin, nice, nl, nohup, nproc, numfmt, od, paste, pathchk, pinky, pr, printenv, printf, ptx, pwd_bin, readlink_bin, realpath_bin, rm_bin, rmdir, runcon, seq, sha1sum, sha224sum, sha256sum, sha384sum, sha512sum, shred, shuf, sleep_bin, sort_bin, split_bin, stat_bin, stdbuf, stty, sum_bin, sync, tac, tail_bin, tee, test, timeout, touch_bin, tr, true_bin, truncate_bin, tsort, tty, uname, unexpand, uniq, unlink_bin, uptime, users, vdir, wc, who, whoami, yes

## Global variables
PATH = ""
LIBPATH = ""
LIBPATH_env = "LD_LIBRARY_PATH"
LIBPATH_default = ""

# Relative path to `b2sum`
const b2sum_splitpath = ["bin", "b2sum"]

# This will be filled out by __init__() for all products, as it must be done at runtime
b2sum_path = ""

# b2sum-specific global declaration
function b2sum(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(b2sum_path)
    end
end


# Relative path to `base32`
const base32_splitpath = ["bin", "base32"]

# This will be filled out by __init__() for all products, as it must be done at runtime
base32_path = ""

# base32-specific global declaration
function base32(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(base32_path)
    end
end


# Relative path to `base64`
const base64_splitpath = ["bin", "base64"]

# This will be filled out by __init__() for all products, as it must be done at runtime
base64_path = ""

# base64-specific global declaration
function base64(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(base64_path)
    end
end


# Relative path to `basename_bin`
const basename_bin_splitpath = ["bin", "basename"]

# This will be filled out by __init__() for all products, as it must be done at runtime
basename_bin_path = ""

# basename_bin-specific global declaration
function basename_bin(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(basename_bin_path)
    end
end


# Relative path to `basenc`
const basenc_splitpath = ["bin", "basenc"]

# This will be filled out by __init__() for all products, as it must be done at runtime
basenc_path = ""

# basenc-specific global declaration
function basenc(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(basenc_path)
    end
end


# Relative path to `cat_bin`
const cat_bin_splitpath = ["bin", "cat"]

# This will be filled out by __init__() for all products, as it must be done at runtime
cat_bin_path = ""

# cat_bin-specific global declaration
function cat_bin(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(cat_bin_path)
    end
end


# Relative path to `chcon`
const chcon_splitpath = ["bin", "chcon"]

# This will be filled out by __init__() for all products, as it must be done at runtime
chcon_path = ""

# chcon-specific global declaration
function chcon(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(chcon_path)
    end
end


# Relative path to `chgrp`
const chgrp_splitpath = ["bin", "chgrp"]

# This will be filled out by __init__() for all products, as it must be done at runtime
chgrp_path = ""

# chgrp-specific global declaration
function chgrp(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(chgrp_path)
    end
end


# Relative path to `chmod_bin`
const chmod_bin_splitpath = ["bin", "chmod"]

# This will be filled out by __init__() for all products, as it must be done at runtime
chmod_bin_path = ""

# chmod_bin-specific global declaration
function chmod_bin(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(chmod_bin_path)
    end
end


# Relative path to `chown_bin`
const chown_bin_splitpath = ["bin", "chown"]

# This will be filled out by __init__() for all products, as it must be done at runtime
chown_bin_path = ""

# chown_bin-specific global declaration
function chown_bin(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(chown_bin_path)
    end
end


# Relative path to `chroot`
const chroot_splitpath = ["bin", "chroot"]

# This will be filled out by __init__() for all products, as it must be done at runtime
chroot_path = ""

# chroot-specific global declaration
function chroot(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(chroot_path)
    end
end


# Relative path to `cksum`
const cksum_splitpath = ["bin", "cksum"]

# This will be filled out by __init__() for all products, as it must be done at runtime
cksum_path = ""

# cksum-specific global declaration
function cksum(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(cksum_path)
    end
end


# Relative path to `comm`
const comm_splitpath = ["bin", "comm"]

# This will be filled out by __init__() for all products, as it must be done at runtime
comm_path = ""

# comm-specific global declaration
function comm(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(comm_path)
    end
end


# Relative path to `cp_bin`
const cp_bin_splitpath = ["bin", "cp"]

# This will be filled out by __init__() for all products, as it must be done at runtime
cp_bin_path = ""

# cp_bin-specific global declaration
function cp_bin(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(cp_bin_path)
    end
end


# Relative path to `csplit`
const csplit_splitpath = ["bin", "csplit"]

# This will be filled out by __init__() for all products, as it must be done at runtime
csplit_path = ""

# csplit-specific global declaration
function csplit(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(csplit_path)
    end
end


# Relative path to `cut`
const cut_splitpath = ["bin", "cut"]

# This will be filled out by __init__() for all products, as it must be done at runtime
cut_path = ""

# cut-specific global declaration
function cut(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(cut_path)
    end
end


# Relative path to `date`
const date_splitpath = ["bin", "date"]

# This will be filled out by __init__() for all products, as it must be done at runtime
date_path = ""

# date-specific global declaration
function date(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(date_path)
    end
end


# Relative path to `dd`
const dd_splitpath = ["bin", "dd"]

# This will be filled out by __init__() for all products, as it must be done at runtime
dd_path = ""

# dd-specific global declaration
function dd(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(dd_path)
    end
end


# Relative path to `df`
const df_splitpath = ["bin", "df"]

# This will be filled out by __init__() for all products, as it must be done at runtime
df_path = ""

# df-specific global declaration
function df(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(df_path)
    end
end


# Relative path to `dir`
const dir_splitpath = ["bin", "dir"]

# This will be filled out by __init__() for all products, as it must be done at runtime
dir_path = ""

# dir-specific global declaration
function dir(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(dir_path)
    end
end


# Relative path to `dircolors`
const dircolors_splitpath = ["bin", "dircolors"]

# This will be filled out by __init__() for all products, as it must be done at runtime
dircolors_path = ""

# dircolors-specific global declaration
function dircolors(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(dircolors_path)
    end
end


# Relative path to `dirname_bin`
const dirname_bin_splitpath = ["bin", "dirname"]

# This will be filled out by __init__() for all products, as it must be done at runtime
dirname_bin_path = ""

# dirname_bin-specific global declaration
function dirname_bin(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(dirname_bin_path)
    end
end


# Relative path to `du`
const du_splitpath = ["bin", "du"]

# This will be filled out by __init__() for all products, as it must be done at runtime
du_path = ""

# du-specific global declaration
function du(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(du_path)
    end
end


# Relative path to `echo`
const echo_splitpath = ["bin", "echo"]

# This will be filled out by __init__() for all products, as it must be done at runtime
echo_path = ""

# echo-specific global declaration
function echo(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(echo_path)
    end
end


# Relative path to `env`
const env_splitpath = ["bin", "env"]

# This will be filled out by __init__() for all products, as it must be done at runtime
env_path = ""

# env-specific global declaration
function env(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(env_path)
    end
end


# Relative path to `expand`
const expand_splitpath = ["bin", "expand"]

# This will be filled out by __init__() for all products, as it must be done at runtime
expand_path = ""

# expand-specific global declaration
function expand(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(expand_path)
    end
end


# Relative path to `expr`
const expr_splitpath = ["bin", "expr"]

# This will be filled out by __init__() for all products, as it must be done at runtime
expr_path = ""

# expr-specific global declaration
function expr(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(expr_path)
    end
end


# Relative path to `factor`
const factor_splitpath = ["bin", "factor"]

# This will be filled out by __init__() for all products, as it must be done at runtime
factor_path = ""

# factor-specific global declaration
function factor(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(factor_path)
    end
end


# Relative path to `false_bin`
const false_bin_splitpath = ["bin", "false"]

# This will be filled out by __init__() for all products, as it must be done at runtime
false_bin_path = ""

# false_bin-specific global declaration
function false_bin(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(false_bin_path)
    end
end


# Relative path to `fmt`
const fmt_splitpath = ["bin", "fmt"]

# This will be filled out by __init__() for all products, as it must be done at runtime
fmt_path = ""

# fmt-specific global declaration
function fmt(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(fmt_path)
    end
end


# Relative path to `fold`
const fold_splitpath = ["bin", "fold"]

# This will be filled out by __init__() for all products, as it must be done at runtime
fold_path = ""

# fold-specific global declaration
function fold(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(fold_path)
    end
end


# Relative path to `groups`
const groups_splitpath = ["bin", "groups"]

# This will be filled out by __init__() for all products, as it must be done at runtime
groups_path = ""

# groups-specific global declaration
function groups(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(groups_path)
    end
end


# Relative path to `head`
const head_splitpath = ["bin", "head"]

# This will be filled out by __init__() for all products, as it must be done at runtime
head_path = ""

# head-specific global declaration
function head(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(head_path)
    end
end


# Relative path to `hostid`
const hostid_splitpath = ["bin", "hostid"]

# This will be filled out by __init__() for all products, as it must be done at runtime
hostid_path = ""

# hostid-specific global declaration
function hostid(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(hostid_path)
    end
end


# Relative path to `id`
const id_splitpath = ["bin", "id"]

# This will be filled out by __init__() for all products, as it must be done at runtime
id_path = ""

# id-specific global declaration
function id(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(id_path)
    end
end


# Relative path to `install`
const install_splitpath = ["bin", "install"]

# This will be filled out by __init__() for all products, as it must be done at runtime
install_path = ""

# install-specific global declaration
function install(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(install_path)
    end
end


# Relative path to `join_bin`
const join_bin_splitpath = ["bin", "join"]

# This will be filled out by __init__() for all products, as it must be done at runtime
join_bin_path = ""

# join_bin-specific global declaration
function join_bin(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(join_bin_path)
    end
end


# Relative path to `kill_bin`
const kill_bin_splitpath = ["bin", "kill"]

# This will be filled out by __init__() for all products, as it must be done at runtime
kill_bin_path = ""

# kill_bin-specific global declaration
function kill_bin(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(kill_bin_path)
    end
end


# Relative path to `left_bracket`
const left_bracket_splitpath = ["bin", "["]

# This will be filled out by __init__() for all products, as it must be done at runtime
left_bracket_path = ""

# left_bracket-specific global declaration
function left_bracket(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(left_bracket_path)
    end
end


# Relative path to `libstdbuf`
const libstdbuf_splitpath = ["libexec", "coreutils", "libstdbuf.so"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libstdbuf_path = ""

# libstdbuf-specific global declaration
# This will be filled out by __init__()
libstdbuf_handle = C_NULL

# This must be `const` so that we can use it with `ccall()`
const libstdbuf = "libstdbuf.so"


# Relative path to `link`
const link_splitpath = ["bin", "link"]

# This will be filled out by __init__() for all products, as it must be done at runtime
link_path = ""

# link-specific global declaration
function link(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(link_path)
    end
end


# Relative path to `ln`
const ln_splitpath = ["bin", "ln"]

# This will be filled out by __init__() for all products, as it must be done at runtime
ln_path = ""

# ln-specific global declaration
function ln(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(ln_path)
    end
end


# Relative path to `logname`
const logname_splitpath = ["bin", "logname"]

# This will be filled out by __init__() for all products, as it must be done at runtime
logname_path = ""

# logname-specific global declaration
function logname(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(logname_path)
    end
end


# Relative path to `ls`
const ls_splitpath = ["bin", "ls"]

# This will be filled out by __init__() for all products, as it must be done at runtime
ls_path = ""

# ls-specific global declaration
function ls(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(ls_path)
    end
end


# Relative path to `md5sum`
const md5sum_splitpath = ["bin", "md5sum"]

# This will be filled out by __init__() for all products, as it must be done at runtime
md5sum_path = ""

# md5sum-specific global declaration
function md5sum(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(md5sum_path)
    end
end


# Relative path to `mkdir_bin`
const mkdir_bin_splitpath = ["bin", "mkdir"]

# This will be filled out by __init__() for all products, as it must be done at runtime
mkdir_bin_path = ""

# mkdir_bin-specific global declaration
function mkdir_bin(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(mkdir_bin_path)
    end
end


# Relative path to `mkfifo`
const mkfifo_splitpath = ["bin", "mkfifo"]

# This will be filled out by __init__() for all products, as it must be done at runtime
mkfifo_path = ""

# mkfifo-specific global declaration
function mkfifo(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(mkfifo_path)
    end
end


# Relative path to `mknod`
const mknod_splitpath = ["bin", "mknod"]

# This will be filled out by __init__() for all products, as it must be done at runtime
mknod_path = ""

# mknod-specific global declaration
function mknod(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(mknod_path)
    end
end


# Relative path to `mktemp_bin`
const mktemp_bin_splitpath = ["bin", "mktemp"]

# This will be filled out by __init__() for all products, as it must be done at runtime
mktemp_bin_path = ""

# mktemp_bin-specific global declaration
function mktemp_bin(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(mktemp_bin_path)
    end
end


# Relative path to `mv_bin`
const mv_bin_splitpath = ["bin", "mv"]

# This will be filled out by __init__() for all products, as it must be done at runtime
mv_bin_path = ""

# mv_bin-specific global declaration
function mv_bin(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(mv_bin_path)
    end
end


# Relative path to `nice`
const nice_splitpath = ["bin", "nice"]

# This will be filled out by __init__() for all products, as it must be done at runtime
nice_path = ""

# nice-specific global declaration
function nice(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(nice_path)
    end
end


# Relative path to `nl`
const nl_splitpath = ["bin", "nl"]

# This will be filled out by __init__() for all products, as it must be done at runtime
nl_path = ""

# nl-specific global declaration
function nl(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(nl_path)
    end
end


# Relative path to `nohup`
const nohup_splitpath = ["bin", "nohup"]

# This will be filled out by __init__() for all products, as it must be done at runtime
nohup_path = ""

# nohup-specific global declaration
function nohup(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(nohup_path)
    end
end


# Relative path to `nproc`
const nproc_splitpath = ["bin", "nproc"]

# This will be filled out by __init__() for all products, as it must be done at runtime
nproc_path = ""

# nproc-specific global declaration
function nproc(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(nproc_path)
    end
end


# Relative path to `numfmt`
const numfmt_splitpath = ["bin", "numfmt"]

# This will be filled out by __init__() for all products, as it must be done at runtime
numfmt_path = ""

# numfmt-specific global declaration
function numfmt(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(numfmt_path)
    end
end


# Relative path to `od`
const od_splitpath = ["bin", "od"]

# This will be filled out by __init__() for all products, as it must be done at runtime
od_path = ""

# od-specific global declaration
function od(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(od_path)
    end
end


# Relative path to `paste`
const paste_splitpath = ["bin", "paste"]

# This will be filled out by __init__() for all products, as it must be done at runtime
paste_path = ""

# paste-specific global declaration
function paste(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(paste_path)
    end
end


# Relative path to `pathchk`
const pathchk_splitpath = ["bin", "pathchk"]

# This will be filled out by __init__() for all products, as it must be done at runtime
pathchk_path = ""

# pathchk-specific global declaration
function pathchk(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(pathchk_path)
    end
end


# Relative path to `pinky`
const pinky_splitpath = ["bin", "pinky"]

# This will be filled out by __init__() for all products, as it must be done at runtime
pinky_path = ""

# pinky-specific global declaration
function pinky(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(pinky_path)
    end
end


# Relative path to `pr`
const pr_splitpath = ["bin", "pr"]

# This will be filled out by __init__() for all products, as it must be done at runtime
pr_path = ""

# pr-specific global declaration
function pr(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(pr_path)
    end
end


# Relative path to `printenv`
const printenv_splitpath = ["bin", "printenv"]

# This will be filled out by __init__() for all products, as it must be done at runtime
printenv_path = ""

# printenv-specific global declaration
function printenv(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(printenv_path)
    end
end


# Relative path to `printf`
const printf_splitpath = ["bin", "printf"]

# This will be filled out by __init__() for all products, as it must be done at runtime
printf_path = ""

# printf-specific global declaration
function printf(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(printf_path)
    end
end


# Relative path to `ptx`
const ptx_splitpath = ["bin", "ptx"]

# This will be filled out by __init__() for all products, as it must be done at runtime
ptx_path = ""

# ptx-specific global declaration
function ptx(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(ptx_path)
    end
end


# Relative path to `pwd_bin`
const pwd_bin_splitpath = ["bin", "pwd"]

# This will be filled out by __init__() for all products, as it must be done at runtime
pwd_bin_path = ""

# pwd_bin-specific global declaration
function pwd_bin(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(pwd_bin_path)
    end
end


# Relative path to `readlink_bin`
const readlink_bin_splitpath = ["bin", "readlink"]

# This will be filled out by __init__() for all products, as it must be done at runtime
readlink_bin_path = ""

# readlink_bin-specific global declaration
function readlink_bin(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(readlink_bin_path)
    end
end


# Relative path to `realpath_bin`
const realpath_bin_splitpath = ["bin", "realpath"]

# This will be filled out by __init__() for all products, as it must be done at runtime
realpath_bin_path = ""

# realpath_bin-specific global declaration
function realpath_bin(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(realpath_bin_path)
    end
end


# Relative path to `rm_bin`
const rm_bin_splitpath = ["bin", "rm"]

# This will be filled out by __init__() for all products, as it must be done at runtime
rm_bin_path = ""

# rm_bin-specific global declaration
function rm_bin(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(rm_bin_path)
    end
end


# Relative path to `rmdir`
const rmdir_splitpath = ["bin", "rmdir"]

# This will be filled out by __init__() for all products, as it must be done at runtime
rmdir_path = ""

# rmdir-specific global declaration
function rmdir(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(rmdir_path)
    end
end


# Relative path to `runcon`
const runcon_splitpath = ["bin", "runcon"]

# This will be filled out by __init__() for all products, as it must be done at runtime
runcon_path = ""

# runcon-specific global declaration
function runcon(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(runcon_path)
    end
end


# Relative path to `seq`
const seq_splitpath = ["bin", "seq"]

# This will be filled out by __init__() for all products, as it must be done at runtime
seq_path = ""

# seq-specific global declaration
function seq(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(seq_path)
    end
end


# Relative path to `sha1sum`
const sha1sum_splitpath = ["bin", "sha1sum"]

# This will be filled out by __init__() for all products, as it must be done at runtime
sha1sum_path = ""

# sha1sum-specific global declaration
function sha1sum(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(sha1sum_path)
    end
end


# Relative path to `sha224sum`
const sha224sum_splitpath = ["bin", "sha224sum"]

# This will be filled out by __init__() for all products, as it must be done at runtime
sha224sum_path = ""

# sha224sum-specific global declaration
function sha224sum(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(sha224sum_path)
    end
end


# Relative path to `sha256sum`
const sha256sum_splitpath = ["bin", "sha256sum"]

# This will be filled out by __init__() for all products, as it must be done at runtime
sha256sum_path = ""

# sha256sum-specific global declaration
function sha256sum(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(sha256sum_path)
    end
end


# Relative path to `sha384sum`
const sha384sum_splitpath = ["bin", "sha384sum"]

# This will be filled out by __init__() for all products, as it must be done at runtime
sha384sum_path = ""

# sha384sum-specific global declaration
function sha384sum(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(sha384sum_path)
    end
end


# Relative path to `sha512sum`
const sha512sum_splitpath = ["bin", "sha512sum"]

# This will be filled out by __init__() for all products, as it must be done at runtime
sha512sum_path = ""

# sha512sum-specific global declaration
function sha512sum(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(sha512sum_path)
    end
end


# Relative path to `shred`
const shred_splitpath = ["bin", "shred"]

# This will be filled out by __init__() for all products, as it must be done at runtime
shred_path = ""

# shred-specific global declaration
function shred(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(shred_path)
    end
end


# Relative path to `shuf`
const shuf_splitpath = ["bin", "shuf"]

# This will be filled out by __init__() for all products, as it must be done at runtime
shuf_path = ""

# shuf-specific global declaration
function shuf(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(shuf_path)
    end
end


# Relative path to `sleep_bin`
const sleep_bin_splitpath = ["bin", "sleep"]

# This will be filled out by __init__() for all products, as it must be done at runtime
sleep_bin_path = ""

# sleep_bin-specific global declaration
function sleep_bin(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(sleep_bin_path)
    end
end


# Relative path to `sort_bin`
const sort_bin_splitpath = ["bin", "sort"]

# This will be filled out by __init__() for all products, as it must be done at runtime
sort_bin_path = ""

# sort_bin-specific global declaration
function sort_bin(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(sort_bin_path)
    end
end


# Relative path to `split_bin`
const split_bin_splitpath = ["bin", "split"]

# This will be filled out by __init__() for all products, as it must be done at runtime
split_bin_path = ""

# split_bin-specific global declaration
function split_bin(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(split_bin_path)
    end
end


# Relative path to `stat_bin`
const stat_bin_splitpath = ["bin", "stat"]

# This will be filled out by __init__() for all products, as it must be done at runtime
stat_bin_path = ""

# stat_bin-specific global declaration
function stat_bin(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(stat_bin_path)
    end
end


# Relative path to `stdbuf`
const stdbuf_splitpath = ["bin", "stdbuf"]

# This will be filled out by __init__() for all products, as it must be done at runtime
stdbuf_path = ""

# stdbuf-specific global declaration
function stdbuf(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(stdbuf_path)
    end
end


# Relative path to `stty`
const stty_splitpath = ["bin", "stty"]

# This will be filled out by __init__() for all products, as it must be done at runtime
stty_path = ""

# stty-specific global declaration
function stty(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(stty_path)
    end
end


# Relative path to `sum_bin`
const sum_bin_splitpath = ["bin", "sum"]

# This will be filled out by __init__() for all products, as it must be done at runtime
sum_bin_path = ""

# sum_bin-specific global declaration
function sum_bin(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(sum_bin_path)
    end
end


# Relative path to `sync`
const sync_splitpath = ["bin", "sync"]

# This will be filled out by __init__() for all products, as it must be done at runtime
sync_path = ""

# sync-specific global declaration
function sync(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(sync_path)
    end
end


# Relative path to `tac`
const tac_splitpath = ["bin", "tac"]

# This will be filled out by __init__() for all products, as it must be done at runtime
tac_path = ""

# tac-specific global declaration
function tac(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(tac_path)
    end
end


# Relative path to `tail_bin`
const tail_bin_splitpath = ["bin", "tail"]

# This will be filled out by __init__() for all products, as it must be done at runtime
tail_bin_path = ""

# tail_bin-specific global declaration
function tail_bin(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(tail_bin_path)
    end
end


# Relative path to `tee`
const tee_splitpath = ["bin", "tee"]

# This will be filled out by __init__() for all products, as it must be done at runtime
tee_path = ""

# tee-specific global declaration
function tee(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(tee_path)
    end
end


# Relative path to `test`
const test_splitpath = ["bin", "test"]

# This will be filled out by __init__() for all products, as it must be done at runtime
test_path = ""

# test-specific global declaration
function test(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(test_path)
    end
end


# Relative path to `timeout`
const timeout_splitpath = ["bin", "timeout"]

# This will be filled out by __init__() for all products, as it must be done at runtime
timeout_path = ""

# timeout-specific global declaration
function timeout(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(timeout_path)
    end
end


# Relative path to `touch_bin`
const touch_bin_splitpath = ["bin", "touch"]

# This will be filled out by __init__() for all products, as it must be done at runtime
touch_bin_path = ""

# touch_bin-specific global declaration
function touch_bin(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(touch_bin_path)
    end
end


# Relative path to `tr`
const tr_splitpath = ["bin", "tr"]

# This will be filled out by __init__() for all products, as it must be done at runtime
tr_path = ""

# tr-specific global declaration
function tr(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(tr_path)
    end
end


# Relative path to `true_bin`
const true_bin_splitpath = ["bin", "true"]

# This will be filled out by __init__() for all products, as it must be done at runtime
true_bin_path = ""

# true_bin-specific global declaration
function true_bin(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(true_bin_path)
    end
end


# Relative path to `truncate_bin`
const truncate_bin_splitpath = ["bin", "truncate"]

# This will be filled out by __init__() for all products, as it must be done at runtime
truncate_bin_path = ""

# truncate_bin-specific global declaration
function truncate_bin(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(truncate_bin_path)
    end
end


# Relative path to `tsort`
const tsort_splitpath = ["bin", "tsort"]

# This will be filled out by __init__() for all products, as it must be done at runtime
tsort_path = ""

# tsort-specific global declaration
function tsort(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(tsort_path)
    end
end


# Relative path to `tty`
const tty_splitpath = ["bin", "tty"]

# This will be filled out by __init__() for all products, as it must be done at runtime
tty_path = ""

# tty-specific global declaration
function tty(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(tty_path)
    end
end


# Relative path to `uname`
const uname_splitpath = ["bin", "uname"]

# This will be filled out by __init__() for all products, as it must be done at runtime
uname_path = ""

# uname-specific global declaration
function uname(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(uname_path)
    end
end


# Relative path to `unexpand`
const unexpand_splitpath = ["bin", "unexpand"]

# This will be filled out by __init__() for all products, as it must be done at runtime
unexpand_path = ""

# unexpand-specific global declaration
function unexpand(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(unexpand_path)
    end
end


# Relative path to `uniq`
const uniq_splitpath = ["bin", "uniq"]

# This will be filled out by __init__() for all products, as it must be done at runtime
uniq_path = ""

# uniq-specific global declaration
function uniq(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(uniq_path)
    end
end


# Relative path to `unlink_bin`
const unlink_bin_splitpath = ["bin", "unlink"]

# This will be filled out by __init__() for all products, as it must be done at runtime
unlink_bin_path = ""

# unlink_bin-specific global declaration
function unlink_bin(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(unlink_bin_path)
    end
end


# Relative path to `uptime`
const uptime_splitpath = ["bin", "uptime"]

# This will be filled out by __init__() for all products, as it must be done at runtime
uptime_path = ""

# uptime-specific global declaration
function uptime(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(uptime_path)
    end
end


# Relative path to `users`
const users_splitpath = ["bin", "users"]

# This will be filled out by __init__() for all products, as it must be done at runtime
users_path = ""

# users-specific global declaration
function users(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(users_path)
    end
end


# Relative path to `vdir`
const vdir_splitpath = ["bin", "vdir"]

# This will be filled out by __init__() for all products, as it must be done at runtime
vdir_path = ""

# vdir-specific global declaration
function vdir(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(vdir_path)
    end
end


# Relative path to `wc`
const wc_splitpath = ["bin", "wc"]

# This will be filled out by __init__() for all products, as it must be done at runtime
wc_path = ""

# wc-specific global declaration
function wc(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(wc_path)
    end
end


# Relative path to `who`
const who_splitpath = ["bin", "who"]

# This will be filled out by __init__() for all products, as it must be done at runtime
who_path = ""

# who-specific global declaration
function who(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(who_path)
    end
end


# Relative path to `whoami`
const whoami_splitpath = ["bin", "whoami"]

# This will be filled out by __init__() for all products, as it must be done at runtime
whoami_path = ""

# whoami-specific global declaration
function whoami(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(whoami_path)
    end
end


# Relative path to `yes`
const yes_splitpath = ["bin", "yes"]

# This will be filled out by __init__() for all products, as it must be done at runtime
yes_path = ""

# yes-specific global declaration
function yes(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(yes_path)
    end
end


"""
Open all libraries
"""
function __init__()
    global artifact_dir = abspath(artifact"coreutils")

    # Initialize PATH and LIBPATH environment variable listings
    global PATH_list, LIBPATH_list
    global b2sum_path = normpath(joinpath(artifact_dir, b2sum_splitpath...))

    push!(PATH_list, dirname(b2sum_path))
    global base32_path = normpath(joinpath(artifact_dir, base32_splitpath...))

    push!(PATH_list, dirname(base32_path))
    global base64_path = normpath(joinpath(artifact_dir, base64_splitpath...))

    push!(PATH_list, dirname(base64_path))
    global basename_bin_path = normpath(joinpath(artifact_dir, basename_bin_splitpath...))

    push!(PATH_list, dirname(basename_bin_path))
    global basenc_path = normpath(joinpath(artifact_dir, basenc_splitpath...))

    push!(PATH_list, dirname(basenc_path))
    global cat_bin_path = normpath(joinpath(artifact_dir, cat_bin_splitpath...))

    push!(PATH_list, dirname(cat_bin_path))
    global chcon_path = normpath(joinpath(artifact_dir, chcon_splitpath...))

    push!(PATH_list, dirname(chcon_path))
    global chgrp_path = normpath(joinpath(artifact_dir, chgrp_splitpath...))

    push!(PATH_list, dirname(chgrp_path))
    global chmod_bin_path = normpath(joinpath(artifact_dir, chmod_bin_splitpath...))

    push!(PATH_list, dirname(chmod_bin_path))
    global chown_bin_path = normpath(joinpath(artifact_dir, chown_bin_splitpath...))

    push!(PATH_list, dirname(chown_bin_path))
    global chroot_path = normpath(joinpath(artifact_dir, chroot_splitpath...))

    push!(PATH_list, dirname(chroot_path))
    global cksum_path = normpath(joinpath(artifact_dir, cksum_splitpath...))

    push!(PATH_list, dirname(cksum_path))
    global comm_path = normpath(joinpath(artifact_dir, comm_splitpath...))

    push!(PATH_list, dirname(comm_path))
    global cp_bin_path = normpath(joinpath(artifact_dir, cp_bin_splitpath...))

    push!(PATH_list, dirname(cp_bin_path))
    global csplit_path = normpath(joinpath(artifact_dir, csplit_splitpath...))

    push!(PATH_list, dirname(csplit_path))
    global cut_path = normpath(joinpath(artifact_dir, cut_splitpath...))

    push!(PATH_list, dirname(cut_path))
    global date_path = normpath(joinpath(artifact_dir, date_splitpath...))

    push!(PATH_list, dirname(date_path))
    global dd_path = normpath(joinpath(artifact_dir, dd_splitpath...))

    push!(PATH_list, dirname(dd_path))
    global df_path = normpath(joinpath(artifact_dir, df_splitpath...))

    push!(PATH_list, dirname(df_path))
    global dir_path = normpath(joinpath(artifact_dir, dir_splitpath...))

    push!(PATH_list, dirname(dir_path))
    global dircolors_path = normpath(joinpath(artifact_dir, dircolors_splitpath...))

    push!(PATH_list, dirname(dircolors_path))
    global dirname_bin_path = normpath(joinpath(artifact_dir, dirname_bin_splitpath...))

    push!(PATH_list, dirname(dirname_bin_path))
    global du_path = normpath(joinpath(artifact_dir, du_splitpath...))

    push!(PATH_list, dirname(du_path))
    global echo_path = normpath(joinpath(artifact_dir, echo_splitpath...))

    push!(PATH_list, dirname(echo_path))
    global env_path = normpath(joinpath(artifact_dir, env_splitpath...))

    push!(PATH_list, dirname(env_path))
    global expand_path = normpath(joinpath(artifact_dir, expand_splitpath...))

    push!(PATH_list, dirname(expand_path))
    global expr_path = normpath(joinpath(artifact_dir, expr_splitpath...))

    push!(PATH_list, dirname(expr_path))
    global factor_path = normpath(joinpath(artifact_dir, factor_splitpath...))

    push!(PATH_list, dirname(factor_path))
    global false_bin_path = normpath(joinpath(artifact_dir, false_bin_splitpath...))

    push!(PATH_list, dirname(false_bin_path))
    global fmt_path = normpath(joinpath(artifact_dir, fmt_splitpath...))

    push!(PATH_list, dirname(fmt_path))
    global fold_path = normpath(joinpath(artifact_dir, fold_splitpath...))

    push!(PATH_list, dirname(fold_path))
    global groups_path = normpath(joinpath(artifact_dir, groups_splitpath...))

    push!(PATH_list, dirname(groups_path))
    global head_path = normpath(joinpath(artifact_dir, head_splitpath...))

    push!(PATH_list, dirname(head_path))
    global hostid_path = normpath(joinpath(artifact_dir, hostid_splitpath...))

    push!(PATH_list, dirname(hostid_path))
    global id_path = normpath(joinpath(artifact_dir, id_splitpath...))

    push!(PATH_list, dirname(id_path))
    global install_path = normpath(joinpath(artifact_dir, install_splitpath...))

    push!(PATH_list, dirname(install_path))
    global join_bin_path = normpath(joinpath(artifact_dir, join_bin_splitpath...))

    push!(PATH_list, dirname(join_bin_path))
    global kill_bin_path = normpath(joinpath(artifact_dir, kill_bin_splitpath...))

    push!(PATH_list, dirname(kill_bin_path))
    global left_bracket_path = normpath(joinpath(artifact_dir, left_bracket_splitpath...))

    push!(PATH_list, dirname(left_bracket_path))
    global libstdbuf_path = normpath(joinpath(artifact_dir, libstdbuf_splitpath...))

    # Manually `dlopen()` this right now so that future invocations
    # of `ccall` with its `SONAME` will find this path immediately.
    global libstdbuf_handle = dlopen(libstdbuf_path)
    push!(LIBPATH_list, dirname(libstdbuf_path))

    global link_path = normpath(joinpath(artifact_dir, link_splitpath...))

    push!(PATH_list, dirname(link_path))
    global ln_path = normpath(joinpath(artifact_dir, ln_splitpath...))

    push!(PATH_list, dirname(ln_path))
    global logname_path = normpath(joinpath(artifact_dir, logname_splitpath...))

    push!(PATH_list, dirname(logname_path))
    global ls_path = normpath(joinpath(artifact_dir, ls_splitpath...))

    push!(PATH_list, dirname(ls_path))
    global md5sum_path = normpath(joinpath(artifact_dir, md5sum_splitpath...))

    push!(PATH_list, dirname(md5sum_path))
    global mkdir_bin_path = normpath(joinpath(artifact_dir, mkdir_bin_splitpath...))

    push!(PATH_list, dirname(mkdir_bin_path))
    global mkfifo_path = normpath(joinpath(artifact_dir, mkfifo_splitpath...))

    push!(PATH_list, dirname(mkfifo_path))
    global mknod_path = normpath(joinpath(artifact_dir, mknod_splitpath...))

    push!(PATH_list, dirname(mknod_path))
    global mktemp_bin_path = normpath(joinpath(artifact_dir, mktemp_bin_splitpath...))

    push!(PATH_list, dirname(mktemp_bin_path))
    global mv_bin_path = normpath(joinpath(artifact_dir, mv_bin_splitpath...))

    push!(PATH_list, dirname(mv_bin_path))
    global nice_path = normpath(joinpath(artifact_dir, nice_splitpath...))

    push!(PATH_list, dirname(nice_path))
    global nl_path = normpath(joinpath(artifact_dir, nl_splitpath...))

    push!(PATH_list, dirname(nl_path))
    global nohup_path = normpath(joinpath(artifact_dir, nohup_splitpath...))

    push!(PATH_list, dirname(nohup_path))
    global nproc_path = normpath(joinpath(artifact_dir, nproc_splitpath...))

    push!(PATH_list, dirname(nproc_path))
    global numfmt_path = normpath(joinpath(artifact_dir, numfmt_splitpath...))

    push!(PATH_list, dirname(numfmt_path))
    global od_path = normpath(joinpath(artifact_dir, od_splitpath...))

    push!(PATH_list, dirname(od_path))
    global paste_path = normpath(joinpath(artifact_dir, paste_splitpath...))

    push!(PATH_list, dirname(paste_path))
    global pathchk_path = normpath(joinpath(artifact_dir, pathchk_splitpath...))

    push!(PATH_list, dirname(pathchk_path))
    global pinky_path = normpath(joinpath(artifact_dir, pinky_splitpath...))

    push!(PATH_list, dirname(pinky_path))
    global pr_path = normpath(joinpath(artifact_dir, pr_splitpath...))

    push!(PATH_list, dirname(pr_path))
    global printenv_path = normpath(joinpath(artifact_dir, printenv_splitpath...))

    push!(PATH_list, dirname(printenv_path))
    global printf_path = normpath(joinpath(artifact_dir, printf_splitpath...))

    push!(PATH_list, dirname(printf_path))
    global ptx_path = normpath(joinpath(artifact_dir, ptx_splitpath...))

    push!(PATH_list, dirname(ptx_path))
    global pwd_bin_path = normpath(joinpath(artifact_dir, pwd_bin_splitpath...))

    push!(PATH_list, dirname(pwd_bin_path))
    global readlink_bin_path = normpath(joinpath(artifact_dir, readlink_bin_splitpath...))

    push!(PATH_list, dirname(readlink_bin_path))
    global realpath_bin_path = normpath(joinpath(artifact_dir, realpath_bin_splitpath...))

    push!(PATH_list, dirname(realpath_bin_path))
    global rm_bin_path = normpath(joinpath(artifact_dir, rm_bin_splitpath...))

    push!(PATH_list, dirname(rm_bin_path))
    global rmdir_path = normpath(joinpath(artifact_dir, rmdir_splitpath...))

    push!(PATH_list, dirname(rmdir_path))
    global runcon_path = normpath(joinpath(artifact_dir, runcon_splitpath...))

    push!(PATH_list, dirname(runcon_path))
    global seq_path = normpath(joinpath(artifact_dir, seq_splitpath...))

    push!(PATH_list, dirname(seq_path))
    global sha1sum_path = normpath(joinpath(artifact_dir, sha1sum_splitpath...))

    push!(PATH_list, dirname(sha1sum_path))
    global sha224sum_path = normpath(joinpath(artifact_dir, sha224sum_splitpath...))

    push!(PATH_list, dirname(sha224sum_path))
    global sha256sum_path = normpath(joinpath(artifact_dir, sha256sum_splitpath...))

    push!(PATH_list, dirname(sha256sum_path))
    global sha384sum_path = normpath(joinpath(artifact_dir, sha384sum_splitpath...))

    push!(PATH_list, dirname(sha384sum_path))
    global sha512sum_path = normpath(joinpath(artifact_dir, sha512sum_splitpath...))

    push!(PATH_list, dirname(sha512sum_path))
    global shred_path = normpath(joinpath(artifact_dir, shred_splitpath...))

    push!(PATH_list, dirname(shred_path))
    global shuf_path = normpath(joinpath(artifact_dir, shuf_splitpath...))

    push!(PATH_list, dirname(shuf_path))
    global sleep_bin_path = normpath(joinpath(artifact_dir, sleep_bin_splitpath...))

    push!(PATH_list, dirname(sleep_bin_path))
    global sort_bin_path = normpath(joinpath(artifact_dir, sort_bin_splitpath...))

    push!(PATH_list, dirname(sort_bin_path))
    global split_bin_path = normpath(joinpath(artifact_dir, split_bin_splitpath...))

    push!(PATH_list, dirname(split_bin_path))
    global stat_bin_path = normpath(joinpath(artifact_dir, stat_bin_splitpath...))

    push!(PATH_list, dirname(stat_bin_path))
    global stdbuf_path = normpath(joinpath(artifact_dir, stdbuf_splitpath...))

    push!(PATH_list, dirname(stdbuf_path))
    global stty_path = normpath(joinpath(artifact_dir, stty_splitpath...))

    push!(PATH_list, dirname(stty_path))
    global sum_bin_path = normpath(joinpath(artifact_dir, sum_bin_splitpath...))

    push!(PATH_list, dirname(sum_bin_path))
    global sync_path = normpath(joinpath(artifact_dir, sync_splitpath...))

    push!(PATH_list, dirname(sync_path))
    global tac_path = normpath(joinpath(artifact_dir, tac_splitpath...))

    push!(PATH_list, dirname(tac_path))
    global tail_bin_path = normpath(joinpath(artifact_dir, tail_bin_splitpath...))

    push!(PATH_list, dirname(tail_bin_path))
    global tee_path = normpath(joinpath(artifact_dir, tee_splitpath...))

    push!(PATH_list, dirname(tee_path))
    global test_path = normpath(joinpath(artifact_dir, test_splitpath...))

    push!(PATH_list, dirname(test_path))
    global timeout_path = normpath(joinpath(artifact_dir, timeout_splitpath...))

    push!(PATH_list, dirname(timeout_path))
    global touch_bin_path = normpath(joinpath(artifact_dir, touch_bin_splitpath...))

    push!(PATH_list, dirname(touch_bin_path))
    global tr_path = normpath(joinpath(artifact_dir, tr_splitpath...))

    push!(PATH_list, dirname(tr_path))
    global true_bin_path = normpath(joinpath(artifact_dir, true_bin_splitpath...))

    push!(PATH_list, dirname(true_bin_path))
    global truncate_bin_path = normpath(joinpath(artifact_dir, truncate_bin_splitpath...))

    push!(PATH_list, dirname(truncate_bin_path))
    global tsort_path = normpath(joinpath(artifact_dir, tsort_splitpath...))

    push!(PATH_list, dirname(tsort_path))
    global tty_path = normpath(joinpath(artifact_dir, tty_splitpath...))

    push!(PATH_list, dirname(tty_path))
    global uname_path = normpath(joinpath(artifact_dir, uname_splitpath...))

    push!(PATH_list, dirname(uname_path))
    global unexpand_path = normpath(joinpath(artifact_dir, unexpand_splitpath...))

    push!(PATH_list, dirname(unexpand_path))
    global uniq_path = normpath(joinpath(artifact_dir, uniq_splitpath...))

    push!(PATH_list, dirname(uniq_path))
    global unlink_bin_path = normpath(joinpath(artifact_dir, unlink_bin_splitpath...))

    push!(PATH_list, dirname(unlink_bin_path))
    global uptime_path = normpath(joinpath(artifact_dir, uptime_splitpath...))

    push!(PATH_list, dirname(uptime_path))
    global users_path = normpath(joinpath(artifact_dir, users_splitpath...))

    push!(PATH_list, dirname(users_path))
    global vdir_path = normpath(joinpath(artifact_dir, vdir_splitpath...))

    push!(PATH_list, dirname(vdir_path))
    global wc_path = normpath(joinpath(artifact_dir, wc_splitpath...))

    push!(PATH_list, dirname(wc_path))
    global who_path = normpath(joinpath(artifact_dir, who_splitpath...))

    push!(PATH_list, dirname(who_path))
    global whoami_path = normpath(joinpath(artifact_dir, whoami_splitpath...))

    push!(PATH_list, dirname(whoami_path))
    global yes_path = normpath(joinpath(artifact_dir, yes_splitpath...))

    push!(PATH_list, dirname(yes_path))
    # Filter out duplicate and empty entries in our PATH and LIBPATH entries
    filter!(!isempty, unique!(PATH_list))
    filter!(!isempty, unique!(LIBPATH_list))
    global PATH = join(PATH_list, ':')
    global LIBPATH = join(vcat(LIBPATH_list, [joinpath(Sys.BINDIR, Base.LIBDIR, "julia"), joinpath(Sys.BINDIR, Base.LIBDIR)]), ':')

    
end  # __init__()

